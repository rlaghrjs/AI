# -*- coding: utf-8 -*-
"""인공지능_미니프로젝트.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xOOl8HIrt9o3hfq4xSYDQGNKk0SEIXG3

# 이상치 확인
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# 데이터 불러오기
df = pd.read_csv('SeoulBikeData.csv')

numeric_columns = ['Temperature(C)', 'Humidity(%)', 'Wind speed (m/s)', 'Rainfall(mm)', 'Snowfall (cm)', 'Rented Bike Count']

plt.figure(figsize=(12, 8))

for i, col in enumerate(numeric_columns):
    plt.subplot(2, 3, i+1)
    sns.boxplot(x=df[col])
    plt.title(f'Boxplot of {col}')

plt.tight_layout()
plt.show()

"""# 서울 자전거 공유 수요 모델"""

import numpy as np
import pandas as pd
from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.callbacks import EarlyStopping, ModelCheckpoint
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler

# 데이터 로드
df = pd.read_csv('SeoulBikeData.csv')

# 날짜를 datetime으로 변환
df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%Y')

# 시간(순환성 표시)
df['Hour_sin'] = np.sin(2 * np.pi * df['Hour'] / 24)
df['Hour_cos'] = np.cos(2 * np.pi * df['Hour'] / 24)

# 요일을 구분(0(월) ~ 6(일))
df['Weekday'] = df['Date'].dt.weekday
# 주말을 구분
df['isWeekend'] = df['Weekday'].isin([5, 6]).astype(int)

# 월간(순환성표시)
df['Month'] = df['Date'].dt.month
df['Month_sin'] = np.sin(2 * np.pi * df['Month'] / 12)
df['Month_cos'] = np.cos(2 * np.pi * df['Month'] / 12)

# Holiday와 Functioning Day는 0 또는 1로 변환
df['Holiday'] = np.where(df['Holiday'] == 'Holiday', 1, 0)
df['Functioning Day'] = np.where(df['Functioning Day'] == 'Functioning Day', 1, 0)

# 원핫 인코딩
df = pd.get_dummies(df, columns=['Seasons', 'Weekday'])

y = df['Rented Bike Count']
X = df.drop(columns=['Date', 'Rented Bike Count'])

# 정규화
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)
X = pd.DataFrame(X_scaled, columns=X.columns)

# 훈련/테스트 분리
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, shuffle=True)

# 모델 구성
model = Sequential()
model.add(Dense(64, activation='relu', input_shape=(X_train.shape[1],)))
model.add(Dense(32, activation='relu'))
model.add(Dense(1))

model.compile(loss='mse', optimizer='adam', metrics=['mse'])

# 콜백 설정
early_stopping_callback = EarlyStopping(monitor='val_loss', patience=20)

modelpath = '/content/Seoul_Bike_sharing_model.keras'

checkpointer = ModelCheckpoint(filepath=modelpath, monitor='val_loss', verbose=1, save_best_only=True)

# 모델 학습
history = model.fit(X_train, y_train, validation_split=0.25, epochs=2000, batch_size=32, callbacks=[early_stopping_callback, checkpointer]
)

# 테스트 평가
score = model.evaluate(X_test, y_test)
print('Test MSE:', score[1])

"""# 예측결과 MSE : 69862

"""

# 예측
y_pred = model.predict(X_test)

# 예측 결과
print("예측 값 :", y_pred)

# 실제 값과 비교
print("실제 값 :", y_test.values)

"""# 하이퍼파라미터 조정 1"""

import numpy as np
import pandas as pd
from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.callbacks import EarlyStopping, ModelCheckpoint
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler

# 데이터 로드
df = pd.read_csv('SeoulBikeData.csv')

# 날짜를 datetime으로 변환
df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%Y')

# 시간(순환성 표시)
df['Hour_sin'] = np.sin(2 * np.pi * df['Hour'] / 24)
df['Hour_cos'] = np.cos(2 * np.pi * df['Hour'] / 24)

# 요일을 구분(0(월) ~ 6(일))
df['Weekday'] = df['Date'].dt.weekday
# 주말을 구분
df['isWeekend'] = df['Weekday'].isin([5, 6]).astype(int)

# 월간(순환성표시)
df['Month'] = df['Date'].dt.month
df['Month_sin'] = np.sin(2 * np.pi * df['Month'] / 12)
df['Month_cos'] = np.cos(2 * np.pi * df['Month'] / 12)

# Holiday와 Functioning Day는 0 또는 1로 변환
df['Holiday'] = np.where(df['Holiday'] == 'Holiday', 1, 0)
df['Functioning Day'] = np.where(df['Functioning Day'] == 'Functioning Day', 1, 0)

# 원핫 인코딩
df = pd.get_dummies(df, columns=['Seasons', 'Weekday'])

y = df['Rented Bike Count']
X = df.drop(columns=['Date', 'Rented Bike Count'])

# 정규화
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)
X = pd.DataFrame(X_scaled, columns=X.columns)

# 훈련/테스트 분리
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, shuffle=True)

# 모델 구성
model = Sequential()
model.add(Dense(64, activation='relu', input_shape=(X_train.shape[1],)))
model.add(Dense(32, activation='relu'))
model.add(Dense(1))

model.compile(loss='mse', optimizer='adam', metrics=['mse'])

# 콜백 설정
early_stopping_callback = EarlyStopping(monitor='val_loss', patience=20)

modelpath = '/content/Seoul_Bike_sharing_model.keras'

checkpointer = ModelCheckpoint(filepath=modelpath, monitor='val_loss', verbose=1, save_best_only=True)

# 모델 학습
history = model.fit(X_train, y_train, validation_split=0.25, epochs=2000, batch_size=64, callbacks=[early_stopping_callback, checkpointer]
)

# 테스트 평가
score = model.evaluate(X_test, y_test)
print('Test MSE:', score[1])

"""# 예측결과2 (배치사이즈 32 -> 16) : MSE : 81249"""

# 예측
y_pred = model.predict(X_test)

# 예측 결과
print("예측 값 :", y_pred)

# 실제 값과 비교
print("실제 값 :", y_test.values)

"""# 예측결과3 (배치사이즈 32 -> 64) MSE: 75429"""

# 예측
y_pred = model.predict(X_test)

# 예측 결과
print("예측 값 :", y_pred)

# 실제 값과 비교
print("실제 값 :", y_test.values)

"""# 하이퍼파라미터 조정 2"""

import numpy as np
import pandas as pd
from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.callbacks import EarlyStopping, ModelCheckpoint
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler

# 데이터 로드
df = pd.read_csv('SeoulBikeData.csv')

# 날짜를 datetime으로 변환
df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%Y')

# 시간(순환성 표시)
df['Hour_sin'] = np.sin(2 * np.pi * df['Hour'] / 24)
df['Hour_cos'] = np.cos(2 * np.pi * df['Hour'] / 24)

# 요일을 구분(0(월) ~ 6(일))
df['Weekday'] = df['Date'].dt.weekday
# 주말을 구분
df['isWeekend'] = df['Weekday'].isin([5, 6]).astype(int)

# 월간(순환성표시)
df['Month'] = df['Date'].dt.month
df['Month_sin'] = np.sin(2 * np.pi * df['Month'] / 12)
df['Month_cos'] = np.cos(2 * np.pi * df['Month'] / 12)

# Holiday와 Functioning Day는 0 또는 1로 변환
df['Holiday'] = np.where(df['Holiday'] == 'Holiday', 1, 0)
df['Functioning Day'] = np.where(df['Functioning Day'] == 'Functioning Day', 1, 0)

# 원핫 인코딩
df = pd.get_dummies(df, columns=['Seasons', 'Weekday'])

y = df['Rented Bike Count']
X = df.drop(columns=['Date', 'Rented Bike Count'])

# 정규화
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)
X = pd.DataFrame(X_scaled, columns=X.columns)

# 훈련/테스트 분리
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, shuffle=True)

# 모델 구성
model = Sequential()
model.add(Dense(256, activation='relu', input_shape=(X_train.shape[1],)))
model.add(Dense(128, activation='relu'))
model.add(Dense(64, activation='relu'))
model.add(Dense(1))

model.compile(loss='mse', optimizer='adam', metrics=['mse'])

# 콜백 설정
early_stopping_callback = EarlyStopping(monitor='val_loss', patience=20)

modelpath = '/content/Seoul_Bike_sharing_model.keras'

checkpointer = ModelCheckpoint(filepath=modelpath, monitor='val_loss', verbose=1, save_best_only=True)

# 모델 학습
history = model.fit(X_train, y_train, validation_split=0.25, epochs=2000, batch_size=32, callbacks=[early_stopping_callback, checkpointer]
)

# 테스트 평가
score = model.evaluate(X_test, y_test)
print('Test MSE:', score[1])

"""# 예측결과4 (배치사이즈 32, 은닉층 128, 64, 32) MSE : 64537"""

# 예측
y_pred = model.predict(X_test)

# 예측 결과
print("예측 값 :", y_pred)

# 실제 값과 비교
print("실제 값 :", y_test.values)

"""# 예측결과5 (배치사이즈 32, 은닉층 256, 128, 64) MSE : 57894"""

# 예측
y_pred = model.predict(X_test)

# 예측 결과
print("예측 값 :", y_pred)

# 실제 값과 비교
print("실제 값 :", y_test.values)

"""# 예측결과6 (배치사이즈 32, 은닉층 64, 32, 16) MSE : 73604"""

# 예측
y_pred = model.predict(X_test)

# 예측 결과
print("예측 값 :", y_pred)

# 실제 값과 비교
print("실제 값 :", y_test.values)

"""# 하이퍼파라미터 조정 3"""

import numpy as np
import pandas as pd
from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.callbacks import EarlyStopping, ModelCheckpoint
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler

# 데이터 로드
df = pd.read_csv('SeoulBikeData.csv')

# 날짜를 datetime으로 변환
df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%Y')

# 시간(순환성 표시)
df['Hour_sin'] = np.sin(2 * np.pi * df['Hour'] / 24)
df['Hour_cos'] = np.cos(2 * np.pi * df['Hour'] / 24)

# 요일을 구분(0(월) ~ 6(일))
df['Weekday'] = df['Date'].dt.weekday
# 주말을 구분
df['isWeekend'] = df['Weekday'].isin([5, 6]).astype(int)

# 월간(순환성표시)
df['Month'] = df['Date'].dt.month
df['Month_sin'] = np.sin(2 * np.pi * df['Month'] / 12)
df['Month_cos'] = np.cos(2 * np.pi * df['Month'] / 12)

# Holiday와 Functioning Day는 0 또는 1로 변환
df['Holiday'] = np.where(df['Holiday'] == 'Holiday', 1, 0)
df['Functioning Day'] = np.where(df['Functioning Day'] == 'Functioning Day', 1, 0)

# 원핫 인코딩
df = pd.get_dummies(df, columns=['Seasons', 'Weekday'])

y = df['Rented Bike Count']
X = df.drop(columns=['Date', 'Rented Bike Count'])

# 정규화
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)
X = pd.DataFrame(X_scaled, columns=X.columns)

# 훈련/테스트 분리
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, shuffle=True)

# 모델 구성
model = Sequential()
model.add(Dense(256, activation='relu', input_shape=(X_train.shape[1],)))
model.add(Dropout(0.3))
model.add(Dense(128, activation='relu'))
model.add(Dropout(0.3))
model.add(Dense(64, activation='relu'))
model.add(Dropout(0.3))
model.add(Dense(1))

model.compile(loss='mse', optimizer='adam', metrics=['mse'])

# 콜백 설정
early_stopping_callback = EarlyStopping(monitor='val_loss', patience=20)

modelpath = '/content/Seoul_Bike_sharing_model.keras'

checkpointer = ModelCheckpoint(filepath=modelpath, monitor='val_loss', verbose=1, save_best_only=True)

# 모델 학습
history = model.fit(X_train, y_train, validation_split=0.25, epochs=2000, batch_size=32, callbacks=[early_stopping_callback, checkpointer]
)

# 테스트 평가
score = model.evaluate(X_test, y_test)
print('Test MSE:', score[1])

"""# 예측결과 7 (드롭아웃층 추가) MSE : 68024"""

# 예측
y_pred = model.predict(X_test)

# 예측 결과
print("예측 값 :", y_pred)

# 실제 값과 비교
print("실제 값 :", y_test.values)

"""최종코드

# 최종코드
"""

"""
배치사이즈 : 32
은닉층 : 3개
뉴런개수 : 256, 128, 64
드롭아웃층 : X
"""

import numpy as np
import pandas as pd
from tensorflow import keras
from keras.models import Sequential
from keras.layers import Dense
from keras.callbacks import EarlyStopping, ModelCheckpoint
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler

# 데이터 로드
df = pd.read_csv('SeoulBikeData.csv')

# 날짜를 datetime으로 변환
df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%Y')

# 시간(순환성 표시)
df['Hour_sin'] = np.sin(2 * np.pi * df['Hour'] / 24)
df['Hour_cos'] = np.cos(2 * np.pi * df['Hour'] / 24)

# 요일을 구분(0(월) ~ 6(일))
df['Weekday'] = df['Date'].dt.weekday
# 주말을 구분
df['isWeekend'] = df['Weekday'].isin([5, 6]).astype(int)

# 월간(순환성표시)
df['Month'] = df['Date'].dt.month
df['Month_sin'] = np.sin(2 * np.pi * df['Month'] / 12)
df['Month_cos'] = np.cos(2 * np.pi * df['Month'] / 12)

# Holiday와 Functioning Day는 0 또는 1로 변환
df['Holiday'] = np.where(df['Holiday'] == 'Holiday', 1, 0)
df['Functioning Day'] = np.where(df['Functioning Day'] == 'Functioning Day', 1, 0)

# 원핫 인코딩
df = pd.get_dummies(df, columns=['Seasons', 'Weekday'])

y = df['Rented Bike Count']
X = df.drop(columns=['Date', 'Rented Bike Count'])

# 정규화
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)
X = pd.DataFrame(X_scaled, columns=X.columns)

# 훈련/테스트 분리
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42, shuffle=True)

# 모델 구성
model = Sequential()
model.add(Dense(256, activation='relu', input_shape=(X_train.shape[1],)))
model.add(Dense(128, activation='relu'))
model.add(Dense(64, activation='relu'))
model.add(Dense(1))

model.compile(loss='mse', optimizer='adam', metrics=['mse'])

# 콜백 설정
early_stopping_callback = EarlyStopping(monitor='val_loss', patience=20)

modelpath = '/content/Seoul_Bike_sharing_model.keras'

checkpointer = ModelCheckpoint(filepath=modelpath, monitor='val_loss', verbose=1, save_best_only=True)

# 모델 학습
history = model.fit(X_train, y_train, validation_split=0.25, epochs=2000, batch_size=32, callbacks=[early_stopping_callback, checkpointer]
)

# 테스트 평가
score = model.evaluate(X_test, y_test)
print('Test MSE:', score[1])